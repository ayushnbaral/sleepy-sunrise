import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation
from matplotlib.patches import Circle

# --- Physical Constants ---
G = 6.6743e-11       # Gravitational constant (m^3 kg^-1 s^-2)
c = 299792458        # Speed of light (m/s)
R_ns = 30000         # Neutron star radius approx. (m)
m1 = 2.78e30         # Mass of star 1 (kg)
m2 = 2.78e30         # Mass of star 2 (kg)
init_dist = 1000e3   # Initial distance between stars (m)
M = m1 + m2
mu = (m1 * m2)/M
eta = mu / M

# --- Simulation Parameters ---
lim = init_dist * 0.7  # Plot limits
merger_triggered = False
explosion_frame = 0

v = np.sqrt(G * (m1 + m2) / (2 * init_dist)) # Initial orbital velocity
T = 3.1415 * init_dist / v                   # Orbital period estimate
pointsPerPeriod = 1000
dt = T / pointsPerPeriod * 1                 # Time step size

# --- Colors ---
start_color = np.array([1.0, 1.0, 1.0])          # White (merger start)
end_color = np.array([0.9, 0.2, 0.2])            # Red (merger end)
start_ejecta_color = np.array([1.0, 0.27, 0.0])  # Hot orange
end_ejecta_color = np.array([1.0, 0.41, 0.71])   # Hot pink

# --- Trailing data lists ---
trail1_x, trail1_y = [], []
trail2_x, trail2_y = [], []

# --- Initial Positions and Velocities ---
r1 = np.array([-init_dist / 2, 0], dtype=float)
r2 = np.array([init_dist / 2, 0], dtype=float)
v1 = np.array([0, v], dtype=float)
v2 = np.array([0, -v], dtype=float)

# --- Ejecta ---
Num_ejecta = 150
ejecta_positions = []
ejecta_velocities = []

# --- Plot Setup ---
fig, ax = plt.subplots()
ax.set_aspect('equal', 'box')
ax.set_xlim(-lim, lim)
ax.set_ylim(-lim, lim)
fig.set_facecolor('#010b19')
ax.set_facecolor('#010b19')

# Hide ticks by coloring them same as background
ax.tick_params(axis='x', colors='#010b19')
ax.tick_params(axis='y', colors='#010b19')

plt.rcParams['font.family'] = 'Franklin Gothic Book'
ax.set_title("Kilonova Simulation", color='white')

# Center of mass marker
plt.scatter([0], [0], color='white', marker='x', label="Center of Mass")

# Stars and trails
pos1_dot, = ax.plot([], [], 'o', color='#703be7', ms=16, label='Star 1', zorder=2)
pos2_dot, = ax.plot([], [], 'o', color='#703be7', ms=16, label='Star 2', zorder=2)
merger = Circle((0, 0), 1, visible=False, zorder=3)
ax.add_patch(merger)

trail1_line, = ax.plot([], [], '-', color='r', lw=0.75, zorder=1)
trail2_line, = ax.plot([], [], '-', color='w', lw=0.75, zorder=1)

# Ejecta scatter plot
ejecta_scatter = ax.scatter([], [], s=5, alpha=0.8, zorder=2)

# White spines for contrast
for spine in ax.spines.values():
    spine.set_color('white')

def relative_vectors(r1, r2, v1, v2):
    r_vec = r2-r1
    v_vec = v2-v1
    r = np.linalg.norm(r_vec)
    v = np.linalg.norm(v_vec)
    n_hat = r_vec / r
    return r, v, n_hat, r_vec, v_vec

def acceleration_newton(r, n_hat):
    return - (G * M) / r**2 * n_hat

def acceleration_1PN(r, v, n_hat, v_vec):
    v_dot_n = np.dot(v_vec, n_hat)
    term1 = (1 + 3 * eta) * v**2
    term2 = -2 * (2 + eta) * (G * M / r)
    term3 = -1.5 * eta * v_dot_n**2
    a_1PN = - (G * M) / r**2 * (n_hat * (term1 + term2 + term3) - 2 * (2 - eta) * v_dot_n * v_vec) / c**2
    return a_1PN

def acceleration_2_5PN(r, v, n_hat, v_vec):
    v_dot_n = np.dot(v_vec, n_hat)
    coeff = (8/5) * eta * (G**2 * M**2) / (c**5 * r**3)
    a_2_5PN = -coeff * (v_vec * (6 * v**2 - 2 * (G * M / r) - 15 * v_dot_n**2) - n_hat * v_dot_n * (18 * v**2 + (2/3) * (G * M / r) - 25 * v_dot_n**2))
    return a_2_5PN

def compute_accelerations(r1, r2, v1, v2):
    r, v, n_hat, r_vec, v_vec = relative_vectors(r1, r2, v1, v2)
    a_newton = acceleration_newton(r, n_hat)
    a_1pn = acceleration_1PN(r, v, n_hat, v_vec)
    a_2_5pn = acceleration_2_5PN(r, v, n_hat, v_vec)
    a_rel = a_newton + a_1pn + a_2_5pn

    a1 = (m2 / M) * a_rel
    a2 = -(m1 / M) * a_rel
    return a1, a2



def rk4_step(r1, r2, v1, v2, dt):
    """Corrected RK4 integrator for two-body system with mutual acceleration."""
    global merger_triggered

    # Early exit on merger
    if np.linalg.norm(r2 - r1) < 2 * R_ns:
        merger_triggered = True
        return r1, r2, v1, v2

    # --- k1 ---
    a1_k1, a2_k1 = compute_accelerations(r1, r2, v1, v2)
    k1_r1 = v1
    k1_r2 = v2
    k1_v1 = a1_k1
    k1_v2 = a2_k1

    # --- k2 ---
    r1_k2 = r1 + 0.5 * dt * k1_r1
    r2_k2 = r2 + 0.5 * dt * k1_r2
    v1_k2 = v1 + 0.5 * dt * k1_v1
    v2_k2 = v2 + 0.5 * dt * k1_v2
    a1_k2, a2_k2 = compute_accelerations(r1_k2, r2_k2, v1_k2, v2_k2)

    # --- k3 ---
    r1_k3 = r1 + 0.5 * dt * v1_k2
    r2_k3 = r2 + 0.5 * dt * v2_k2
    v1_k3 = v1 + 0.5 * dt * a1_k2
    v2_k3 = v2 + 0.5 * dt * a2_k2
    a1_k3, a2_k3 = compute_accelerations(r1_k3, r2_k3, v1_k3, v2_k3)

    # --- k4 ---
    r1_k4 = r1 + dt * v1_k3
    r2_k4 = r2 + dt * v2_k3
    v1_k4 = v1 + dt * a1_k3
    v2_k4 = v2 + dt * a2_k3
    a1_k4, a2_k4 = compute_accelerations(r1_k4, r2_k4, v1_k4, v2_k4)

    # Combine increments
    r1_new = r1 + (dt / 6) * (k1_r1 + 2 * v1_k2 + 2 * v1_k3 + v1_k4)
    r2_new = r2 + (dt / 6) * (k1_r2 + 2 * v2_k2 + 2 * v2_k3 + v2_k4)
    v1_new = v1 + (dt / 6) * (k1_v1 + 2 * a1_k2 + 2 * a1_k3 + a1_k4)
    v2_new = v2 + (dt / 6) * (k1_v2 + 2 * a2_k2 + 2 * a2_k3 + a2_k4)

    return r1_new, r2_new, v1_new, v2_new



def init():
    """Initialize animation frame."""
    pos1_dot.set_data([], [])
    pos2_dot.set_data([], [])
    trail1_line.set_data([], [])
    trail2_line.set_data([], [])
    merger.set_visible(False)
    merger.set_radius(1)
    ejecta_scatter.set_offsets(np.empty((0, 2)))
    ejecta_scatter.set_alpha(0.0)
    return pos1_dot, pos2_dot, trail1_line, trail2_line, ejecta_scatter


def update(frame):
    """Update function for animation."""
    global r1, r2, v1, v2, explosion_frame

    r1, r2, v1, v2 = rk4_step(r1, r2, v1, v2, dt)

    if merger_triggered:
        # Hide stars and trails
        pos1_dot.set_data([], [])
        pos2_dot.set_data([], [])
        trail1_line.set_data([], [])
        trail2_line.set_data([], [])

        merger.set_visible(True)
        merger.set_radius(50000 * np.sqrt(explosion_frame + 1))

        t = min(explosion_frame / 50, 1.0)
        color = (1 - t) * start_color + t * end_color
        merger.set_facecolor(color)
        merger.set_alpha(1.0 - t)

        # Initialize ejecta on first explosion frame
        if explosion_frame == 0:
            ejecta_positions.clear()
            ejecta_velocities.clear()
            for _ in range(Num_ejecta):
                angle = np.random.uniform(0, 2 * np.pi)
                speed = np.random.uniform(0.5e7, 1.5e7)
                vx = speed * np.cos(angle)
                vy = speed * np.sin(angle)
                ejecta_velocities.append(np.array([vx, vy]))
                ejecta_positions.append(np.array([0.0, 0.0]))

        # Update ejecta positions
        for i in range(Num_ejecta):
            ejecta_positions[i] += ejecta_velocities[i] * dt

        positions_array = np.array(ejecta_positions)
        ejecta_scatter.set_offsets(positions_array)

        t = min(explosion_frame / 100, 1.0)  # Progress 0->1 over 100 frames
        current_color = (1 - t) * start_ejecta_color + t * end_ejecta_color
        colors_array = np.tile(current_color, (Num_ejecta, 1))
        ejecta_scatter.set_facecolor(colors_array)

        ejecta_scatter.set_alpha(max(0.0, 1.0 - explosion_frame / 100))
        explosion_frame += 1

        if explosion_frame > 100:
            ani.event_source.stop()

        return merger, trail1_line, trail2_line, ejecta_scatter

    else:
        # Update trails
        trail1_x.append(r1[0])
        trail1_y.append(r1[1])
        trail2_x.append(r2[0])
        trail2_y.append(r2[1])

        # Limit trail length
        if len(trail1_x) > 50:
            trail1_x.pop(0)
            trail1_y.pop(0)
            trail2_x.pop(0)
            trail2_y.pop(0)

        # Update star positions and trails
        pos1_dot.set_data([r1[0]], [r1[1]])
        pos2_dot.set_data([r2[0]], [r2[1]])
        trail1_line.set_data(trail1_x, trail1_y)
        trail2_line.set_data(trail2_x, trail2_y)

    return pos1_dot, pos2_dot, trail1_line, trail2_line, merger


ani = FuncAnimation(
    fig,
    update,
    init_func=init,
    frames=5000,
    interval=14,
    blit=True
)

plt.show()
